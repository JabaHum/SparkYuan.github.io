[{"title":"SubmitButton动效按钮","date":"2016-07-20T13:33:15.000Z","path":"2016/07/20/SubmitButton动效按钮/","text":"SubmitButtonA practical, cool and elegant Submit Button Github：https://github.com/SparkYuan/SubmitButton Demo Attributes12345678910&lt;com.spark.submitbutton.SubmitButton android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"Submit\" android:textColor=\"@color/gray\" app:sub_btn_background=\"@color/white\" app:sub_btn_duration=\"3000\" app:sub_btn_line_color=\"@color/green\" app:sub_btn_ripple_color=\"@color/green\" app:sub_btn_tick_color=\"@color/white\" /&gt; Notice SubmitButton is a subclass of TextView, so almost all attributes of TextView can be used for SubmitButton. The width and height of this SubmitButton is measured by the text size and its layout_width and layout_height must be match_parent. The default gravity of the text in this SubmitButton is center and can not be changed. DownloadStep 1. Configure your project-level build.gradle to include the follow repository: 12345repositories &#123; maven &#123; url 'https://dl.bintray.com/spark/maven' &#125;&#125; Step 2. Add the dependency: 123dependencies &#123; compile 'me.spark:submitbutton:1.0.1'&#125; LicenseThe MIT License (MIT) Copyright (c) 2016 Spark Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","tags":[{"name":"Android","slug":"Android","permalink":"http://sparkyuan.github.io/tags/Android/"}]},{"title":"一个自定义注解的例子","date":"2016-06-10T07:53:16.000Z","path":"2016/06/10/自定义注解的例子/","text":"一个自定义注解的例子 什么是注解注解是 Java 5 的一个新特性。注解是插入你代码中的一种注释或者说是一种元数据（meta data）。这些注解信息可以在编译期使用预编译工具进行处理（pre-compiler tools），也可以在运行期使用 Java 反射机制进行处理。下面是一个类注解的例子： 123@MyAnnotation(name=\"someName\", value = \"Hello World\")public class TheClass &#123;&#125; 在 TheClass 类定义的上面有一个@MyAnnotation 的注解。注解的定义与接口的定义相似，下面是MyAnnotation注解的定义：1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyAnnotation &#123; public String name(); public String value();&#125; 在 interface 前面的@符号表名这是一个注解，一旦你定义了一个注解之后你就可以将其应用到你的代码中，就像之前我们的那个例子那样。 在注解定义中的两个指示@Retention(RetentionPolicy.RUNTIME)和@Target(ElementType.TYPE)，说明了这个注解该如何使用。 @Retention(RetentionPolicy.RUNTIME)表示这个注解可以在运行期通过反射访问。如果你没有在注解定义的时候使用这个指示那么这个注解的信息不会保留到运行期，这样反射就无法获取它的信息。 @Target(ElementType.TYPE) 表示这个注解只能用在类型上面（比如类跟接口）。你同样可以把Type改为Field或者Method，或者你可以不用这个指示，这样的话你的注解在类，方法和变量上就都可以使用了。 关于 Java 注解更详细的讲解可以访问 Java Annotations tutorial。 详细讲解极客学院的讲解 补充的示例使用反射读取RUNTIME保留策略的Annotation信息的例子： 自定义注解12345@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String[] value1() default \"abc\";&#125; 使用自定义注解12345678public class AnnotationTest2 &#123; @MyAnnotation(value1=&#123;\"a\",\"b\"&#125;) @Deprecated public void execute()&#123; System.out.println(\"method\"); &#125;&#125; 读取注解中的信息12345678910111213141516171819202122public static void main(String[] args) throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; AnnotationTest2 annotationTest2 = new AnnotationTest2(); //获取AnnotationTest2的Class实例 Class&lt;AnnotationTest2&gt; c = AnnotationTest2.class; //获取需要处理的方法Method实例 Method method = c.getMethod(\"execute\", new Class[]&#123;&#125;); //判断该方法是否包含MyAnnotation注解 if(method.isAnnotationPresent(MyAnnotation.class))&#123; //获取该方法的MyAnnotation注解实例 MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class); //执行该方法 method.invoke(annotationTest2, new Object[]&#123;&#125;); //获取myAnnotation String[] value1 = myAnnotation.value1(); System.out.println(value1[0]); &#125; //获取方法上的所有注解 Annotation[] annotations = method.getAnnotations(); for(Annotation annotation : annotations)&#123; System.out.println(annotation); &#125;&#125;","tags":[{"name":"Annotation","slug":"Annotation","permalink":"http://sparkyuan.github.io/tags/Annotation/"}]},{"title":"JVM内存区域分析","date":"2016-04-22T07:38:51.000Z","path":"2016/04/22/JVM运行时数据区域/","text":"Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。 程序计数器（PC）程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码行号指示器。 当前线程所执行的字节码行号指示器 每个线程都有一个 线程私有，生命周期与线程相同，随JVM启动而生，JVM关闭而死 线程执行Java方法时，记录其正在执行的虚拟机字节码指令地址 线程执行Nativan方法时，计数器记录为空（Undefined） 唯一在Java虚拟机规范中没有规定任何OutOfMemoryError情况区域 Java虚拟机栈虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧 （Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。在Java虚拟机规范中，对于此区域规定了两种异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用非常类似，区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 Java堆Java堆是垃圾收集管理的主要战场。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的。 通过-Xmx和-Xms控制Heap大小 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 方法区又称“永久代”(Permanent Generation) 使用XX:MaxPermSize调整最大值 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。","tags":[{"name":"深入理解JVM虚拟机","slug":"深入理解JVM虚拟机","permalink":"http://sparkyuan.github.io/tags/深入理解JVM虚拟机/"}]},{"title":"Android安全机制","date":"2016-04-05T06:45:58.000Z","path":"2016/04/05/Android安全机制/","text":"Android系统是基于Linux内核开发的，因此，Android系统不仅保留和继承了Linux操作系统的安全机制，而且其系统架构的各个层次都有独特的安全特性。 Linux内核安全机制Android的Linux内核包含了强制访问控制机制和自主访问控制机制。强制访问控制机制由Linux安全模块来实现。自主访问控制机制通常由文件访问控制来实现，Linux文件系统的权限控制是由user、group、other与读(r) 、写(w) 、执行(x)的不同组合来实现的。这样，每个文件都有三个基本权限集，它们的组合可以容许、限制、拒绝用户、用户组和其他用户的访问。通常，只有uid是“system”或“root”用户才拥有Android系统文件的访问权限，而应用程序只有通过申请Android权限才能实现对相应文件的访问，也正因为此，Android使用内核层Linux的自主访问控制机制和运行时的Dalvik虚拟机来实现Android的“沙箱”机制。 Android的“沙箱”机制Android“沙箱”的本质是为了实现不同应用程序和进程之间的互相隔离，即在默认情况下，应用程序没有权限访问系统资源或其它应用程序的资源。每个APP和系统进程都被分配唯一并且固定的User Id，这个uid与内核层进程的uid对应。每个APP在各自独立的Dalvik虚拟机中运行，拥有独立的地址空间和资源。运行于Dalvik虚拟机中的进程必须依托内核层Linux进程而存在，因此Android使用Dalvik虚拟机和Linux的文件访问控制来实现沙箱机制，任何应用程序如果想要访问系统资源或者其它应用程序的资源必须在自己的manifest文件中进行声明权限或者共享uid。Android中的数据分为system和data两个区，其中system是只读的，data是用来存放应用自己的数据，这样保证系统数据不会被随意改写。 应用权限机制任何一个应用程序在使用Android受限资源（网络、电话、短信、蓝牙、通讯录、SdCard等）之前都必须以XML文件的形式事先向Android系统提出申请，等待Android系统批准后应用程序方可使用相应的资源，权限与Java的API是多对多的映射关系。 如何让两个app运行在同一个进程里？ 1. 两个app用相同的private key来签名。 2. 两个app的Manifest文件中添加android:sharedUserId 设置成相同的UID。","tags":[{"name":"安全机制","slug":"安全机制","permalink":"http://sparkyuan.github.io/tags/安全机制/"}]},{"title":"从源码到apk——apk打包过程","date":"2016-04-01T08:12:53.000Z","path":"2016/04/01/从源码到APK/","text":"Android程序是怎么从源码变成可以安装使用的apk的 流程官方版 详细版 上面就是一个关于构建过程的一个典型的流程图。 aapt（Android Asset Packaging Tool）给你的Activity提供所需的资源文件,如 AndroidManifest.xml，XML文件,并编译它们。同时产生R.java文件，使你可以在java代码中引用这些资源。 aidl工具把.aidl接口转换成Java接口。 你所有的Java代码,包括 R.java和 .aidl文件,由Java编译器和编译输出.class文件。 dex工具把.class文件转换成Dalvik字节文件，第三方的类和.class也被转换成.dex文件 所有无法编译的资源（比如图片），编译好的资源文件和.dex都被送到apkbuilder工具中，生成最后的.apk 生成.apk时必须制定是debug还是release，release还要提供相应的key 如果选择release版本，还需要使用zipalign工具对apk对齐。齐处理即使得所有资源文件距离文件起始偏移为4字节的整数倍，这样通过内存映射访问apk文件时处理速度更快。 输出生成的apk在app/build/outputs/apk/目录下，命名规则 app--.apk，例如，app-demo-debug.apk.","tags":[{"name":"apk","slug":"apk","permalink":"http://sparkyuan.github.io/tags/apk/"}]},{"title":"使用UncaughtExceptionHandler来处理未捕获的异常","date":"2016-03-28T08:06:51.000Z","path":"2016/03/28/使用UncaughtExceptionHandler来处理未捕获的异常/","text":"所有的App都会发生crash，本文讲解的是如何采集crash信息以供后续开发处理这类问题。 基本思路当crash发生时，系统会调用UncaughtExceptionHandler的uncaughtException方法，我们可以在这个方法中捕获异常信息，把异常信息存到SD卡中，在合适的时候通过网络把crash信息传回服务器，这样就可以分析crash原因，在后续的版本中解决。先看一下Thread类中的一个方法，setDefaultUncaughtExceptionHandler 123public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler handler) &#123; Thread.defaultUncaughtHandler = handler;&#125; defaultUncaughtHandler是Thread类的静态成员变量，所以如果我们将自定义的UncaughtExceptionHandler设置给Thread的话，那么当前进程内的所有线程都能使用这个UncaughtExceptionHandler来处理异常了。 CrashHandler123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class CrashHandler implements UncaughtExceptionHandler &#123; private static final String TAG = \"CrashHandler\"; private static final boolean DEBUG = true; private static final String PATH = Environment.getExternalStorageDirectory().getPath() + \"/CrashTest/log/\"; private static final String FILE_NAME = \"crash\"; private static final String FILE_NAME_SUFFIX = \".trace\"; private static CrashHandler sInstance = new CrashHandler(); private UncaughtExceptionHandler mDefaultCrashHandler; private Context mContext; private CrashHandler() &#123; &#125; public static CrashHandler getInstance() &#123; return sInstance; &#125; //需要初始化的单例 public void init(Context context) &#123; mDefaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler(this); mContext = context.getApplicationContext(); &#125; /** * 这个是最关键的函数，当程序中有未被捕获的异常，系统将会自动调用#uncaughtException方法 * thread为出现未捕获异常的线程，ex为未捕获的异常，有了这个ex，我们就可以得到异常信息。 */ @Override public void uncaughtException(Thread thread, Throwable ex) &#123; try &#123; //导出异常信息到SD卡中 dumpExceptionToSDCard(ex); uploadExceptionToServer(); //这里可以通过网络上传异常信息到服务器，便于开发人员分析日志从而解决bug &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; ex.printStackTrace(); //如果系统提供了默认的异常处理器，则交给系统去结束我们的程序，否则就由我们自己结束自己 if (mDefaultCrashHandler != null) &#123; mDefaultCrashHandler.uncaughtException(thread, ex); &#125; else &#123; Process.killProcess(Process.myPid()); &#125; &#125; private void dumpExceptionToSDCard(Throwable ex) throws IOException &#123; //如果SD卡不存在或无法使用，则无法把异常信息写入SD卡 if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123; if (DEBUG) &#123; Log.w(TAG, \"sdcard unmounted,skip dump exception\"); return; &#125; &#125; File dir = new File(PATH); if (!dir.exists()) &#123; dir.mkdirs(); &#125; long current = System.currentTimeMillis(); String time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date(current)); File file = new File(PATH + FILE_NAME + time + FILE_NAME_SUFFIX); try &#123; PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(file))); pw.println(time); dumpPhoneInfo(pw); pw.println(); ex.printStackTrace(pw); pw.close(); &#125; catch (Exception e) &#123; Log.e(TAG, \"dump crash info failed\"); &#125; &#125; private void dumpPhoneInfo(PrintWriter pw) throws NameNotFoundException &#123; PackageManager pm = mContext.getPackageManager(); PackageInfo pi = pm.getPackageInfo(mContext.getPackageName(), PackageManager.GET_ACTIVITIES); pw.print(\"App Version: \"); pw.print(pi.versionName); pw.print('_'); pw.println(pi.versionCode); //android版本号 pw.print(\"OS Version: \"); pw.print(Build.VERSION.RELEASE); pw.print(\"_\"); pw.println(Build.VERSION.SDK_INT); //手机制造商 pw.print(\"Vendor: \"); pw.println(Build.MANUFACTURER); //手机型号 pw.print(\"Model: \"); pw.println(Build.MODEL); //cpu架构 pw.print(\"CPU ABI: \"); pw.println(Build.CPU_ABI); &#125; private void uploadExceptionToServer() &#123; //TODO Upload Exception Message To Your Web Server &#125;&#125; 使用方法在Application的onCreate方法中配置一下就可以12345678910111213141516171819public class TestApp extends Application &#123; private static TestApp sInstance; @Override public void onCreate() &#123; super.onCreate(); sInstance = this; //在这里为应用设置异常处理程序，然后我们的程序才能捕获未处理的异常 CrashHandler crashHandler = CrashHandler.getInstance(); crashHandler.init(this); &#125; public static TestApp getInstance() &#123; return sInstance; &#125;&#125;","tags":[{"name":"crash","slug":"crash","permalink":"http://sparkyuan.github.io/tags/crash/"}]},{"title":"Android的线程和线程池","date":"2016-03-25T06:02:51.000Z","path":"2016/03/25/Android的线程和线程池/","text":"在Java中默认情况下一个进程只有一个线程，也就是主线程，其他线程都是子线程，也叫工作线程。Android中的主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。线程的创建和销毁的开销较大，所以如果一个进程要频繁地创建和销毁线程的话，都会采用线程池的方式。 Android中线程的形态 传统的Thread AsyncTask HandlerThread IntentService 各种线程形态的比较 传统的Thread这是Java本身就支持的类，自定义化程度高，但是所有的功能都需要自己维护。 AsyncTaskAsyncTask常用于可以在几秒钟完成的后台任务，关于AsyncTask的讲解可以看这一篇文章http://sparkyuan.me/2016/03/23/AsyncTask源码剖析(API 23)/ /)/)讲解了AsyncTask的基本用法和源码分析。 HandlerThreadHandlerThread继承了Thread，是一种可以使用Handler的Thread，它的实现就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。外界可以通过Handler的消息方式通知HandlerThread执行一个具体的任务。HandlerThread的一个应用场景就是用在IntentService中。HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread的时候，可以通过它的quit或者quitSafely方法来终止线程的执行，这是一个良好的编程习惯。 IntentServiceIntentService是一个特殊的Service，它继承自Service并且是个抽象类，要使用它就要创建它的子类。与AsyncTask不同的是，IntentService用于需要长时间执行的任务，因为他是Service，所以他的优先级比单纯的线程高很多。IntentService的onCreate方法中会创建HandlerThread，并使用HandlerThread的Looper来构造一个Handler对象ServiceHandler，这样通过ServiceHandler对象发送的消息最终都会在HandlerThread中执行。IntentService会将Intent封装到Message中，通过ServiceHandler发送出去，在ServiceHandler的handleMessage方法中会调用IntentService的抽象方法onHandleIntent，所以IntentService的子类都要是实现这个方法。 一个例子1234567891011121314151617181920212223public class LocalIntentService extends IntentService &#123; private static final String TAG = \"LocalIntentService\"; public LocalIntentService() &#123; super(TAG); &#125; @Override protected void onHandleIntent(Intent intent) &#123; String action = intent.getStringExtra(\"task_action\"); Log.d(TAG, \"receive task :\" + action); SystemClock.sleep(3000); if (\"com.ryg.action.TASK1\".equals(action)) &#123; Log.d(TAG, \"handle task: \" + action); &#125; &#125; @Override public void onDestroy() &#123; Log.d(TAG, \"service destroyed.\"); super.onDestroy(); &#125;&#125; 123Intent service = new Intent(this, LocalIntentService.class); service.putExtra(\"task_action\", \"com.sparkyuan.com\"); startService(service); Android中的线程池使用线程池的优点 重用线程，避免线程的创建和销毁带来的性能开销； 能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象； 能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。 ThreadPoolExecutorExecutor只是一个接口，真正的线程池是ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池，Android的线程池都是通过Executors提供的工厂方法得到的。123456public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) ThreadFactory threadFactory corePoolSize：核心线程数，默认情况下，核心线程会在线程中一直存活； maximumPoolSize：最大线程数，当活动线程数达到这个数值后，后续的任务将会被阻塞； keepAliveTime：非核心线程闲置时的超时时长，超过这个时长，闲置的非核心线程就会被回收； unit：用于指定keepAliveTime参数的时间单位，有TimeUnit.MILLISECONDS、TimeUnit.SECONDS、TimeUnit.MINUTES等； workQueue：任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中； threadFactory：线程工厂，为线程池提供创建新线程的功能。它是一个接口，它只有一个方法Thread newThread(Runnable r)； RejectedExecutionHandler：当线程池无法执行新任务时，可能是由于任务队列已满或者是无法成功执行任务，这个时候就会调用这个Handler的rejectedExecution方法来通知调用者，默认情况下，rejectedExecution会直接抛出一个rejectedExecutionException。 ThreadPoolExecutor执行任务规则 如果线程池中的线程数未达到核心线程的数量，那么会直接启动一个核心线程来执行任务 如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行 如果在步骤2中无法将任务插入到的任务队列中，可能是任务队列已满，这个时候如果线程数量没有达到规定的最大值，那么会立刻启动非核心线程来执行这个任务 如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。 AsyncTask中的THREAD_POOL_EXECUTOR线程池的配置情况 corePoolSize=CPU核心数+1； maximumPoolSize=2倍的CPU核心数+1； 核心线程无超时机制，非核心线程在闲置时间的超时时间为1s； 任务队列的容量为128。 线程池分类 FixedThreadPool：线程数量固定的线程池，它只有核心线程； CachedThreadPool：线程数量不固定的线程池，它只有非核心线程； ScheduledThreadPool：核心线程数量固定，非核心线程数量没有限制的线程池，主要用于执行定时任务和具有固定周期的任务； SingleThreadPool：只有一个核心线程的线程池，确保了所有的任务都在同一个线程中按顺序执行。 示例1234567891011121314151617181920212223private void runThreadPool() &#123; Runnable command = new Runnable() &#123; @Override public void run() &#123; SystemClock.sleep(2000); &#125; &#125;; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4); fixedThreadPool.execute(command); ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); cachedThreadPool.execute(command); ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4); // 2000ms后执行command scheduledThreadPool.schedule(command, 2000, TimeUnit.MILLISECONDS); // 延迟10ms后，每隔1000ms执行一次command scheduledThreadPool.scheduleAtFixedRate(command, 10, 1000, TimeUnit.MILLISECONDS); ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); singleThreadExecutor.execute(command); &#125;","tags":[{"name":"AsyncTask","slug":"AsyncTask","permalink":"http://sparkyuan.github.io/tags/AsyncTask/"},{"name":"HandlerThread","slug":"HandlerThread","permalink":"http://sparkyuan.github.io/tags/HandlerThread/"},{"name":"IntentService","slug":"IntentService","permalink":"http://sparkyuan.github.io/tags/IntentService/"},{"name":"Thread","slug":"Thread","permalink":"http://sparkyuan.github.io/tags/Thread/"}]},{"title":"AsyncTask源码剖析(API 23)","date":"2016-03-23T08:04:19.000Z","path":"2016/03/23/AsyncTask源码剖析(API 23)/","text":"Android的UI是线程不安全的，想在子线程中更新UI就必须使用Android的异步操作机制，直接在主线程中更新UI会导致程序崩溃。Android的异步操作主要有两种，AsyncTask和Handler。AsyncTask是一个轻量的异步类，简单、可控。本文主要结合API 23的源码讲解一下AsyncTask到底是什么。 基本用法声明：Android不同API版本中同一个类的实现方法可能会有不同，本文是基于最新的API 23的源码进行讲解的。 1public abstract class AsyncTask&lt;Params, Progress, Result&gt; Params：执行时传入的参数Progress：后台任务的执行进度Result：返回值 AsyncTask是个抽象类，所以需要自己定义一个类继承他，比如 1class MyAsyncTask extends AsyncTask&lt;Void, Integer, Boolean&gt; AsyncTask的执行过程： execute(Params… params)，执行异步任务。 onPreExecute()，在execute(Params… params)被调用后执行，界面上的初始化操作，比如显示一个进度条对话框等。 doInBackground(Params… params)，在onPreExecute()完成后执行，用于执行较为费时的操作，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。在执行过程中可以调用publishProgress(Progress… values)来更新进度信息。注意，此方法中不可以进行UI操作。 onProgressUpdate(Progress… values)，调用publishProgress(Progress… values)时，此方法被执行，将进度信息更新到UI组件上。 onPostExecute(Result result)，当后台操作结束时，此方法将会被调用，计算结果将做为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。 示例新建一个Activity，一个Button和一个ProgressBar，点击Button启动一个AsyncTask并实时更新ProgressBar的状态。 MyAsyncTask1234567891011121314151617181920212223242526272829303132333435363738class MyAsyncTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected void onPostExecute(Boolean aBoolean) &#123; super.onPostExecute(aBoolean); &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); progressBar.setProgress(values[0]); &#125; @Override protected Boolean doInBackground(Void... params) &#123; for (int i = 0; i &lt; 100; i++) &#123; //调用publishProgress,触发onProgressUpdate方法 publishProgress(i); try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; @Override protected void onCancelled() &#123; super.onCancelled(); progressBar.setProgress(0); &#125; &#125; Button的Click方法1234567startAsyncBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; myAsyncTask = new MyAsyncTask(); myAsyncTask.execute(); &#125; &#125;); 源码剖析通过上面的例子可以发现，AsyncTask使用起来很简单，很方便的就可以在主线程中新建一个子线程进行UI的更新等操作。但是他的实现并不像使用起来那么简单，下面就是对AsyncTask的源码进行剖析。 AsyncTask的构造函数123456789101112131415161718192021222324252627public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; 在构造函数中只做了两件事，初始化mWorker和mFuture两个变量。mWorker是一个Callable对象，mFutre是一个FutureTask对象。execute()时会用到。 execute(Params… params)123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125; 只有一行代码，调用了executeOnExecutor方法，sDefaultExecutor实际上是一个串行的线程池，一个进程中所有的AsyncTask全部在这个串行的线程池中排队执行。executeOnExecutor源码如下。 1234567891011121314151617181920public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; 可以看到在这个方法里调用了onPreExecute()，接下来执行exec.execute(mFuture)下面分析一一下线程池的执行过程。 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 系统先把AsyncTask的Params参数封装为FutureTask对象，FutureTask是一个并发类，这里它相当于Runnable；接着将FutureTask交给SerialExecutor的execute方法，它先把FutureTask插入到任务队列tasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会执行下一个AsyncTask任务，同时当一个AsyncTask任务执行完毕之后，AsyncTask会继续执行其他任务直到所有任务都被执行为止。从这里就可以看出，默认情况下，AsyncTask是串行执行的看一下AsyncTask的构造函数，mFuture构造时是把mWork作为参数传进去的，mFuture的run方法会调用mWork的call()方法，因此call()最终会在线程池中执行。call()中调用了doInBackground()并把返回结果给了postResult。 1234567private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; 可以看到在postResult中通过getHandler()获得一个Handler。 12345678private static Handler getHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(); &#125; return sHandler; &#125; &#125; 查看getHandler源码，可以发现getHandler返回的是一个InternalHandler，再来看看InternalHandler的源码。 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; 看到这里已经豁然开朗了，InternalHandler是一个继承Handler的类，在他的handleMessage()方法中对msg进行了判断，如果是MESSAGE_POST_RESULT就执行finish()，如果是MESSAGE_POST_PROGRESS，就执行onProgressUpdate()。MESSAGE_POST_PROGRESS消息是在publishProgress里发出的，详情见源码。 123456protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125; &#125; finish()12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED; &#125; 如果当前任务被取消，就调用onCancelled()方法，如果没有调用onPostExecute()。 注意事项 AsyncTask的类必须在主线程中加载，这个过程在Android 4.1及以上版本中已经被系统自动完成。 AsyncTask对象必须在主线程中创建，execute方法必须在UI线程中调用。 一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常。 各个版本的区别在Android 1.6之前，AsyncTask是串行执行任务的，Android 1.6的时候AsyncTask开始采用线程池并行处理任务，但是从Android 3.0开始，为了避免AsyncTask带来的并发错误，AsyncTask又采用一个线程来串行执行任务。尽管如此，在Android 3.0以及后续版本中，我们可以使用AsyncTask的executeOnExecutor方法来并行执行任务。但是这个方法是Android 3.0新添加的方法，并不能在低版本上使用。 总结整个AsyncTask的源码已经剖析完了，在分析完真个源码后可以发现，AsyncTask并没有什么神秘的，他的本质就是Handler。我们现在已经知道了AsyncTask如何使用，各个方法会在什么时候调用，有什么作用，相互之间有什么联系，相信大家以后在遇到AsyncTask的任何问题都不会再害怕了，因为AsyncTask的整个源码都翻了个底朝天，还有什么好怕的呢。","tags":[{"name":"AsyncTask","slug":"AsyncTask","permalink":"http://sparkyuan.github.io/tags/AsyncTask/"},{"name":"Android","slug":"Android","permalink":"http://sparkyuan.github.io/tags/Android/"},{"name":"源码剖析","slug":"源码剖析","permalink":"http://sparkyuan.github.io/tags/源码剖析/"}]},{"title":"从源码的角度理解四大组件的工作过程","date":"2016-03-14T14:35:04.000Z","path":"2016/03/14/四大组件的工作过程/","text":"系统对四大组件的过程进行了很大程度的封装，日常开发中并不需要了解底层的工作原理，那么研究这些原理的意义在哪里呢？ 如果你想在技术上更进一步，那么了解一些系统的工作原理是十分必要的，也是开发人员日后成长为高级工程师所必备的技术能力。 Android作为一个优秀的基于Linux操作系统，其内部一定有很多值得我们学习的地方，通过对Android操作系统的学习对提高开发人员的内功有很大的好处。 如果你从事Android Rom开发，那就没什么好说的了，看源码吧。 本文侧重于对四大组件工作过程的分析，通过分析他们的工作过程理解系统内部运行机制，加深我们对Android整体系统结构的认识。 本文中的UML图来自@amurocrash，感谢amurocrash。Android相关部分的源码实在是太多，全部贴上了太过繁琐，所以借用了amurocrash同学的UML图使得整个流程更加容易理解。 四大组件的运行状态 Activity的主要作用是展示一个界面并和用户交互，它扮演的是一种前台界面的角色。 Service是一种计算型组件，用于在后台执行一系列计算任务。Service有两种状态：启动状态和绑定状态。启动状态时的Service不需要与外界交互，绑定状态的Service可以方便的和Service组件进行通信。Service是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。灵活采用stopService和unBindService这两个方法才能完全停止一个Service组件。 BroadcastReceiver是一种消息型组件，用于在不同的组件乃至不同的应用之间传递消息。广播注册有静态和动态两种方式，动态注册通过Context.registerReceiver()来实现，不需要时通过Contex.unRegisterReceiver()来解除广播，这种方式必须要应用启动才能注册；静态注册则在AndroidManifest文件中进行，应用安装时会被系统解析，不需要启动应用就可接收广播。匹配过程是通过来描述的。 ContentProvider是一种共享型组件，用于向其他组件乃至其他应用共享数据。它内部维持着一份数据集合，并需要实现增删改查这四种操作，这个数据集合既可以通过数据库来实现，也可以采用其他类型来实现，比如List，Map等。需要注意的是，增删改查要处理好线程同步，这几个方法是在Binder线程池中被调用的，另外，ContentProvider不需要手动停止。 Activity的工作过程 注 启动Activity的真实实现是由ActivityManagerNative.getDefault().startActivity方法来完成的。这个方法返回ActivityManagerService。 ActivityManagerService（AMS）继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder。 AMS这个Binder对象采用单例模式对外提供，第一次调用它的get方法时会通过create方法初始化，后续调用中直接返回之前创建的对象。 从makeApplication的实现可以看出，如果Application已经被创建过了，那么就不会再重复创建，这也意味着一个应用只有一个Application对象。Application的创建也是通过Instrumentation来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。 ContextImpl是Context的具体实现，ContextImpl是通过Activity的attach方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当Activity接受到事件就可以传递给window了。 Service的工作过程启动过程 绑定过程注 Service有两种状态：启动状态和绑定状态，两种状态是可以共存的。 BroadcastReceiver的工作过程BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。 动态注册 发送和接收 注： 静态注册是由PackageManagerService（PMS）在应用安装的时候完成整个注册过程的，除广播以外，其他三大组件也都是在应用安装时由PMS解析并注册的。 广播的发送有几种类型：普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是发送和接收过程是类似的。 FLAG_INCLUDE_STOPPED_PACKAGES:广播会发送给已经停止的应用，FLAG_EXCLUDE_STOPPED_PACKAGES广播不会发送给已经停止的应用 从Android 3.1开始，处于停止状态的应用无法接受到开机广播。 ContentProvider启动过程 当ContentProvider所在的进程启动时，会同时被启动并被发布到AMS中，需要注意的是，这个时候它的onCreate要先去Application的onCreate执行，这在四大组件中是一个少有的现象。 用启动的入口为ActivityThread的main方法，main方法会创建ActivityThread实例并创建主线程消息队列。 attach方法中远程调用AMS的attachApplication方法，并提供ApplicationThread用于和AMS的通信。 attachApplication方法会通过bindApplication方法和H来调回ActivityThread的handleBindApplication，这个方法会先创建Application，再加载ContentProvider，然后才会回调Application的onCreate方法。 ContentProvider的multiprocess属性决定了ContentProvider是否是单例（false时），一般都用单例。 ontentResolver的具体类是ApplicationContentResolver，当ContentProvider所在进程未启动时，第一次访问它会触发ContentProvider的创建以及进程启动。 Query流程 insert，delete和update方法类似，这里就不在分析了。","tags":[{"name":"Activity","slug":"Activity","permalink":"http://sparkyuan.github.io/tags/Activity/"},{"name":"Service","slug":"Service","permalink":"http://sparkyuan.github.io/tags/Service/"},{"name":"BroadcastReceiver","slug":"BroadcastReceiver","permalink":"http://sparkyuan.github.io/tags/BroadcastReceiver/"},{"name":"ContentProvider","slug":"ContentProvider","permalink":"http://sparkyuan.github.io/tags/ContentProvider/"}]},{"title":"属性动画","date":"2016-03-11T12:46:25.000Z","path":"2016/03/11/属性动画/","text":"Animator最早出现在Android 3.0 中，和之前的Animation框架相比，Animator更加的灵活并且具有更多的功能，官方推荐使用Animator代替Animation。在3.0之前可以使用nineoldandroids来实现相同的效果。 使用Animator前需要先了解几个概念： Duration：动画播放时间 Time interpolation：属性值随着时间的改变情况，比如线性增长或者先快后慢 Repeat count：动画重复播放次数 Animator sets：动画集，可以使多个动画同时播放或者顺序播放 Frame refresh delay：动画每一帧的刷新时间，一般默认10ms刷新一次 #Property AnimationProperty Animation非常强大，他可以让你几乎在任何东西上播放动画。Property Animation的结构如下图：ValueAnimator用来跟踪动画运行的时间和属性的值。其中TimeInterpolator指定了动画的 interpolation，如AccelerateDecelerateInterpolator。TypeEvaluator指定属性的值如何计算比如IntEvaluator. #示例点击一个Button，Button的宽和高分别增加到500dp和400dp。 #Property Animation与View Animation的区别 View Animation只能对View添加动画 View Animation只能改变如scale、rotation等值，不能改变background color等属性 View Animation改变的只是View画的位置，并不是真正的View，比如一个button从左到右移动，触发onClick方法的位置还是初试的位置。 View Animation实现起来比Property Animation简单 Evaluator以IntEvaluator为例，源码如下：1234public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125; 很简单，就是根据初始值，结束值和当前时间与总时长的比例这三个值计算出当前某属性应该的值。 #AnimatorAnimator提供了创建动画的基本结构，通常我们不直接使用它，而是使用它的子类。 ##ValueAnimator使用ofInt(), ofFloat(), 或者 ofObject()方法来获得ValueAnimator实例 123ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);animation.setDuration(1000);animation.start(); 当然也可以自定义类型 123ValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue);animation.setDuration(1000);animation.start(); ###示例动画的源码1234567891011121314151617button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; final IntEvaluator mEvaluator = new IntEvaluator(); ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; float fraction = valueAnimator.getAnimatedFraction(); button.getLayoutParams().width = mEvaluator.evaluate(fraction, button.getWidth(), 500); button.getLayoutParams().height = mEvaluator.evaluate(fraction, button.getHeight(), 400); button.requestLayout(); &#125; &#125;); valueAnimator.setDuration(1000).start(); &#125; &#125;); 注：别忘了 button.requestLayout()和valueAnimator.setDuration(1000).start()。 ##ObjectAnimatorObjectAnimator是ValueAnimator 的子类。可以直接对目标属性计算。对foo这个对象的alpha属性做从0到1的变化，代码如下： 123ObjectAnimator anim = ObjectAnimator.ofFloat(foo, \"alpha\", 0f, 1f);anim.setDuration(1000);anim.start(); 为了使ObjectAnimator正常运行，还需要如下步骤： 要修改的属性必须有set方法，如setFoo() 如果你在values…参数中只指定了一个参数，默认为这是最后一个参数。参数必须有get方法，如getFoo() 有些属性需要手动刷新，所以要在onAnimationUpdate() 中调用invalidate()。 如果没有要修改的属性必须有set方法，有如下三个解决办法： 如果有权限，添加set方法但是很多情况下我们是没有的… 使用这个类的wrapper class（包装类）ObjectAnimator.ofFloat(wrapper, “alpha”, 0f, 1f),在这个包装类的setAlph中对原来View的alpha属性值进行更改 使用ValueAnimator #AnimatorSet 一个Set中包含多个动画，使用起来也很方便，直接上代码。 1234567891011AnimatorSet bouncer = new AnimatorSet();bouncer.play(bounceAnim).before(squashAnim1);bouncer.play(squashAnim1).with(squashAnim2);bouncer.play(squashAnim1).with(stretchAnim1);bouncer.play(squashAnim1).with(stretchAnim2);bouncer.play(bounceBackAnim).after(stretchAnim2);ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f);fadeAnim.setDuration(250);AnimatorSet animatorSet = new AnimatorSet();animatorSet.play(bouncer).before(fadeAnim);animatorSet.start(); #在XML中声明动画 新建res/animator/目录每种Animator对应的标签 ValueAnimator - ObjectAnimator - AnimatorSet - 123456789101112131415161718&lt;set android:ordering=\"sequentially\"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName=\"x\" android:duration=\"500\" android:valueTo=\"400\" android:valueType=\"intType\"/&gt; &lt;objectAnimator android:propertyName=\"y\" android:duration=\"500\" android:valueTo=\"300\" android:valueType=\"intType\"/&gt; &lt;/set&gt; &lt;objectAnimator android:propertyName=\"alpha\" android:duration=\"500\" android:valueTo=\"1f\"/&gt;&lt;/set&gt; 在Activity中调用 1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator);set.setTarget(myObject);set.start();","tags":[{"name":"Android","slug":"Android","permalink":"http://sparkyuan.github.io/tags/Android/"},{"name":"View","slug":"View","permalink":"http://sparkyuan.github.io/tags/View/"},{"name":"属性动画","slug":"属性动画","permalink":"http://sparkyuan.github.io/tags/属性动画/"}]},{"title":"每日一妹子","date":"2016-03-11T12:46:25.000Z","path":"2016/03/11/Meizi/","text":"MeiziGithub：https://github.com/SparkYuan/Meizi 刚开始学习Android的时候，主要就是学习了一些Activity的生命周期，各种View和Layout的使用，SQLite等零散的知识点，这些东西市面上任何一本Android的入门书籍都会覆盖，但是学习完这些之后就有些迷茫了，不知道下一步该学一些什么？如果你也正好处于这个状态不妨看看这个开源项目。自己走过一些弯路，所以写了一个这样的App，希望可以对学习Android的新手有些帮助。 一个特别适合新手练习的Android小项目——每日一妹纸 每天更新一张@代码家精选妹纸图片，所以叫每日一妹纸，咳咳，不要污，这是一个很绅士的项目（一脸绅士(๑•̀ㅂ•́) ✧） 第一版目前已完成，本项目会持续更新，遇到任何问题欢迎与我联系^_^ 部分示例 为什么说这是一个特别适合新手练习的小项目？ 服务器API接口功能丰富且无访问次数限制 包含了常见的网络通信，数据缓存等功能 包含了常见的Gradle用法 多语言适配 自定义了一个ImageView 使用了流行的Realm，Retrofit，Glide，Butterknife等开源项目，方便新手学习他们的使用 遵循Material Design规则 …… 用到的开源技术 Butterknife Realm Retrofit Glide …… 数据来源http://gank.io 联系方式 博客： Hexo：http://sparkyuan.me/ CSDN：http://blog.csdn.net/l664675249 邮箱：daniellee0929@gmail.com License http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","tags":[{"name":"Android","slug":"Android","permalink":"http://sparkyuan.github.io/tags/Android/"}]},{"title":"Windows和WindowManager","date":"2016-03-11T12:46:25.000Z","path":"2016/03/11/Windows和WindowManager/","text":"Window表示一个窗口的概念，在某些特殊的时候，比如你需要在桌面或者锁屏上显示一些类似悬浮窗的东西时候就需要用到Window。Window是一个抽象类，Window的实现类是PhoneWindow。Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。Android中所有的视图都是通过Window来呈现的，不管是Activity、Dialog还是Toast，他们的视图实际上都是附加在Window上的。 #一个悬浮窗的例子 点击Button按钮，将一个ImageView添加到坐标为（100,300）的位置上，并且可以随手拖动的。 下面是这一段的源码，展示了如何使用WindowManager添加一个Window。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class TestActivity extends Activity implements OnTouchListener &#123; private static final String TAG = \"TestActivity\"; private Button mCreateWindowButton; private ImageView mImageView; private WindowManager.LayoutParams mLayoutParams; private WindowManager mWindowManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); initView(); &#125; private void initView() &#123; mCreateWindowButton = (Button) findViewById(R.id.button1); mWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE); &#125; public void onButtonClick(View v) &#123; if (v == mCreateWindowButton) &#123; mImageView = new ImageView(this); mImageView.setBackgroundResource(R.drawable.ic_launcher); mLayoutParams = new WindowManager.LayoutParams( LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, 0, 0, PixelFormat.TRANSPARENT); mLayoutParams.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_SHOW_WHEN_LOCKED; mLayoutParams.type = LayoutParams.TYPE_SYSTEM_ERROR; mLayoutParams.gravity = Gravity.TOP | Gravity.LEFT; mLayoutParams.x = 100; mLayoutParams.y = 300; mImageView.setOnTouchListener(this); mWindowManager.addView(mImageView, mLayoutParams); &#125; &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; int rawX = (int) event.getRawX(); int rawY = (int) event.getRawY(); int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; break; &#125; case MotionEvent.ACTION_MOVE: &#123; Log.d(TAG, \"onTouch: rawX \" + rawX); Log.d(TAG, \"onTouch: rawY \" + rawY); mLayoutParams.x = rawX; mLayoutParams.y = rawY; mWindowManager.updateViewLayout(mImageView, mLayoutParams); break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; return false; &#125; @Override protected void onDestroy() &#123; try &#123; mWindowManager.removeView(mImageView); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; super.onDestroy(); &#125;&#125; #WindowManager.LayoutParams的Flag和Type ##FLAG FLAG_NOT_FOCUSABLE，当前Window不获取焦点，也不接收各种输入事件，会同时启用FLAG_NOT_TOUCH_MODAL，事件会传递给下层具有焦点的Window。 FLAG_NOT_TOUCH_MODAL，当前Window区域外的单击事件传递给底层，区域内的单击事件自己处理，一般都需要开启。 FLAG_SHOW_WHEN_LOCKED，可以让Window显示在锁屏界面上。 ##TypeType表示Window的类型，有应用Window、子Window和系统Window。 应用Window，一般对应一个Activity。层级范围1～99。 子Window，不能单独存在，需要特定的父Window，比如一般的Dialog。层级范围1000～1999。 系统Window，需要权限声明，比如Toast。层级范围2000～2999。 一般可以选用WindowManager.LayoutParams.TYPE_SYSTEM_ERROR或者TYPE_SYSTEM_OVERLAY同时声明权限。使用WindowManager.LayoutParams.TYPE_SYSTEM_ERROR时，同时声明 #注 Window并不实际存在，以View的形式存在。每个Window对应着一个View和ViewRootImpl，Window和View通过ViewRootImpl建立联系。所以在实际使用中其实我们并不能访问到真正的Window，而只能通过WindowManager。 WindowManager常用的三个功能：addView，updateViewLayout，removeView 别忘了onDestory()中的mWindowManager.removeView(mImageView)","tags":[{"name":"Android","slug":"Android","permalink":"http://sparkyuan.github.io/tags/Android/"},{"name":"Window","slug":"Window","permalink":"http://sparkyuan.github.io/tags/Window/"},{"name":"WindowManager","slug":"WindowManager","permalink":"http://sparkyuan.github.io/tags/WindowManager/"}]},{"title":"一个规范的自定义View","date":"2016-03-11T12:46:25.000Z","path":"2016/03/11/一个规范的自定义View/","text":"一个规范的自定义View 一个不规范的自定义View这个自定义的View很简单，就是画一个圆，实现一个圆形效果的自定义View。 先看一个不规范的自定义View是怎么做的 12345678910111213141516171819202122232425262728293031public class CircleView extends View &#123; private int mColor = Color.RED; private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); public CircleView(Context context) &#123; super(context); init(); &#125; public CircleView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaint.setColor(mColor); &#125; @Override protected void onDraw(Canvas canvas) &#123; int width = getWidth(); int height = getHeight(); int radius = Math.min(width, height) / 2; canvas.drawCircle(width / 2, height / 2, radius, mPaint); &#125;&#125; 对应的xml 1234567&lt;com.ryg.chapter_4.ui.CircleView android:id=\"@+id/circleView1\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:layout_margin=\"20dp\" android:background=\"#000000\" /&gt; 这样虽然也能画出一个圆来，但是这并不是一个规范的自定义View，主要存在以下问题： android:padding属性是不能使用的 使用wrap_content就相当于使用match_partent 一个规范的自定义View为了解决以上问题需要重写View的onMeasure和onDraw方法。 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class CircleView extends View &#123; private int mColor = Color.RED; private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); public CircleView(Context context) &#123; super(context); init(); &#125; public CircleView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleView); mColor = a.getColor(R.styleable.CircleView_circle_color, Color.RED); a.recycle(); init(); &#125; private void init() &#123; mPaint.setColor(mColor); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(200, 200); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(200, heightSpecSize); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(widthSpecSize, 200); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); final int paddingLeft = getPaddingLeft(); final int paddingRight = getPaddingRight(); final int paddingTop = getPaddingTop(); final int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingTop - paddingBottom; int radius = Math.min(width, height) / 2; canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, mPaint); &#125;&#125; 添加自定义属性 在values文件夹下添加attrs.xml 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"CircleView\"&gt; &lt;attr name=\"circle_color\" format=\"color\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 自定义的属性集合CircleView，在这个属性集合里只定义了一个格式为color的属性circle_color。 在View的构造函数中解析自定义的属性 1234567public CircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleView); mColor = a.getColor(R.styleable.CircleView_circle_color, Color.RED); a.recycle(); init(); &#125; 在布局文件中使用自定义属性 12345678&lt;com.ryg.chapter_4.ui.CircleView android:id=\"@+id/circleView1\" android:layout_width=\"wrap_content\" android:layout_height=\"100dp\" android:layout_margin=\"20dp\" android:background=\"#000000\" android:padding=\"20dp\" app:circle_color=\"@color/light_green\" /&gt; 在使用自定义的属性时，要在schemas声明：xmlns:app=”http://schemas.android.com/apk/res-auto&quot;，使用时与普通属性类似，app:circle_color=&quot;@color/light_green“ 。 自定义View须知 自定义的View中margin属性可以使用，因为它是由父容器控制的 直接继承View或ViewGroup的需要自己处理wrap_content View要在onDraw方法中要处理padding，而ViewGroup要在onMeasure和onLayout中处理padding和margin View中的post方法可以取代handler 在View的onDetachedFromWindow中停止动画，防止内存泄露 有滑动嵌套情形时，注意滑动冲突处理 关于上面涉及到的一些类和方法的详细解释请参考http://blog.csdn.net/l664675249/article/details/50774617 想要自定义出漂亮的View并不容易，只有多读，多写，多测，才能更好的掌握。自己造一个轮子，然后再对比成熟的轮子去找差距和不足。","tags":[{"name":"Android","slug":"Android","permalink":"http://sparkyuan.github.io/tags/Android/"},{"name":"View","slug":"View","permalink":"http://sparkyuan.github.io/tags/View/"},{"name":"自定义View","slug":"自定义View","permalink":"http://sparkyuan.github.io/tags/自定义View/"}]},{"title":"View的弹性滑动","date":"2016-03-11T12:46:25.000Z","path":"2016/03/11/View的弹性滑动/","text":"相信开发Android的人都会有这种体会：从网上下载的demo运行的好好的，但是只要出现了滑动冲突，Demo就无法正常工作了。但是不用担心，解决滑动冲突有固定的模式，常见的有内部拦截和外部拦截两种，只要按照这个模式来就可以顺利解决。 介绍相信开发Android的人都会有这种体会：从网上下载的demo运行的好好的，但是只要出现了滑动冲突，Demo就无法正常工作了。但是不用担心，解决滑动冲突有固定的模式，常见的有内部拦截和外部拦截两种，只要按照这个模式来就可以顺利解决。本文会涉及到View事件分发的相关知识，关于事件分发请参考http://sparkyuan.me/2016/03/11/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/ 常见的滑动冲突场景 示例 处理规则对于场景1，处理规则为：当用户左右滑动时，让外部的View拦截点击事件，当用户上下滑动时，让内部的View拦截点击事件。当产生滑动时，根据滑动的起始点与终点坐标位置，如果垂直方向滑动距离大，就判断为垂直滑动，否则判断为水平滑动。其他两种情况处理方法相似，都是从业务需求上得出相应的规则。 解决方法外部拦截发所有的点击事件都先经过父容器拦截处理，如果父容器需要拦截就拦截，不需要就传给内部的View。伪代码如下123456789101112131415161718192021222324252627public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; intercepted = false; break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (满足父容器的拦截要求) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted; &#125; 注：ACTION_DOWN这个事件是不能拦截的，因为一旦拦截后续的事件都会由父容器处理了。 内部拦截法父容器不拦截任何事件，所有事件都传给子元素。如果子元素需要此事件就直接消耗，否则就交给父容器进行处理。完成这个功能需要配合requestDisallowInterceptTouchEvent()方法才可。这个方法表示是否让父容器拦截事件。伪代码如下： 12345678910111213141516171819202122232425public boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; parent.requestDisallowInterceptTouchEvent(true); break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (满足父容器的拦截要求) &#123; parent.requestDisallowInterceptTouchEvent(false); &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event); &#125; 注父容器默认拦截除了ACTION_DOWN以外的其他事件，这样子当元素调用parent.requestDisallowInterceptTouchEvent(false)时，父元素才能拦截所需的事件。 总结 解决滑动冲突有两种方法，推荐外部拦截法，实现起来简单。 本文以场景1为例做了讲解，场景2,3的做法与1类似，都是根据业务需要制定处理规则。 示例效果的源码Activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class DemoActivity_1 extends Activity &#123; private static final String TAG = \"DemoActivity_1\"; private HorizontalScrollViewEx mListContainer; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.demo_1); Log.d(TAG, \"onCreate\"); initView(); &#125; private void initView() &#123; LayoutInflater inflater = getLayoutInflater(); mListContainer = (HorizontalScrollViewEx) findViewById(R.id.container); final int screenWidth = MyUtils.getScreenMetrics(this).widthPixels; final int screenHeight = MyUtils.getScreenMetrics(this).heightPixels; for (int i = 0; i &lt; 3; i++) &#123; ViewGroup layout = (ViewGroup) inflater.inflate( R.layout.content_layout, mListContainer, false); layout.getLayoutParams().width = screenWidth; TextView textView = (TextView) layout.findViewById(R.id.title); textView.setText(\"page \" + (i + 1)); layout.setBackgroundColor(Color.rgb(255 / (i + 1), 255 / (i + 1), 0)); createList(layout); mListContainer.addView(layout); &#125; &#125; private void createList(ViewGroup layout) &#123; ListView listView = (ListView) layout.findViewById(R.id.list); ArrayList&lt;String&gt; datas = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 50; i++) &#123; datas.add(\"name \" + i); &#125; ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.content_list_item, R.id.name, datas); listView.setAdapter(adapter); listView.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Toast.makeText(DemoActivity_1.this, \"click item\", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 水平滑动的View123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202public class HorizontalScrollViewEx extends ViewGroup &#123; private static final String TAG = \"HorizontalScrollViewEx\"; private int mChildrenSize; private int mChildWidth; private int mChildIndex; // 分别记录上次滑动的坐标 private int mLastX = 0; private int mLastY = 0; // 分别记录上次滑动的坐标(onInterceptTouchEvent) private int mLastXIntercept = 0; private int mLastYIntercept = 0; private Scroller mScroller; private VelocityTracker mVelocityTracker; public HorizontalScrollViewEx(Context context) &#123; super(context); init(); &#125; public HorizontalScrollViewEx(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public HorizontalScrollViewEx(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; mScroller = new Scroller(getContext()); mVelocityTracker = VelocityTracker.obtain(); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; Log.d(TAG, \"onInterceptTouchEvent: ACTION_DOWN\"); intercepted = false; if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); intercepted = true; &#125; break; &#125; case MotionEvent.ACTION_MOVE: &#123; Log.d(TAG, \"onInterceptTouchEvent: ACTION_MOVE\"); int deltaX = x - mLastXIntercept; int deltaY = y - mLastYIntercept; if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; Log.d(TAG, \"intercepted=\" + intercepted); mLastX = x; mLastY = y; mLastXIntercept = x; mLastYIntercept = y; return intercepted; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mVelocityTracker.addMovement(event); int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; Log.d(TAG, \"onTouchEvent: ACTION_DOWN\"); if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; break; &#125; case MotionEvent.ACTION_MOVE: &#123; Log.d(TAG, \"onTouchEvent: ACTION_MOVE\"); int deltaX = x - mLastX; int deltaY = y - mLastY; Log.d(TAG, \"onTouchEvent: deltaX\" + deltaX); scrollBy(-deltaX, 0); break; &#125; case MotionEvent.ACTION_UP: &#123; int scrollX = getScrollX(); int scrollToChildIndex = scrollX / mChildWidth; mVelocityTracker.computeCurrentVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity(); //滑的速度到达阈值就认为需要进入下一页 if (Math.abs(xVelocity) &gt;= 100) &#123; mChildIndex = xVelocity &gt; 0 ? mChildIndex - 1 : mChildIndex + 1; &#125; else &#123; //滑动的距离超过一半，就进入下一页 mChildIndex = (scrollX + mChildWidth / 2) / mChildWidth; &#125; //保证在0页和最后一页滑动时不会越界 mChildIndex = Math.max(0, Math.min(mChildIndex, mChildrenSize - 1)); //没有达到进入下一页的要求，恢复原样 int dx = mChildIndex * mChildWidth - scrollX; smoothScrollBy(dx, 0); Log.d(TAG, \"onTouchEvent: dx = \" + dx); mVelocityTracker.clear(); break; &#125; default: break; &#125; mLastX = x; mLastY = y; return true; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measuredWidth = 0; int measuredHeight = 0; final int childCount = getChildCount(); measureChildren(widthMeasureSpec, heightMeasureSpec); int widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); if (childCount == 0) &#123; setMeasuredDimension(0, 0); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; final View childView = getChildAt(0); measuredHeight = childView.getMeasuredHeight(); setMeasuredDimension(widthSpaceSize, childView.getMeasuredHeight()); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; final View childView = getChildAt(0); measuredWidth = childView.getMeasuredWidth() * childCount; setMeasuredDimension(measuredWidth, heightSpaceSize); &#125; else &#123; final View childView = getChildAt(0); measuredWidth = childView.getMeasuredWidth() * childCount; measuredHeight = childView.getMeasuredHeight(); setMeasuredDimension(measuredWidth, measuredHeight); &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childLeft = 0; final int childCount = getChildCount(); mChildrenSize = childCount; for (int i = 0; i &lt; childCount; i++) &#123; final View childView = getChildAt(i); if (childView.getVisibility() != View.GONE) &#123; final int childWidth = childView.getMeasuredWidth(); mChildWidth = childWidth; childView.layout(childLeft, 0, childLeft + childWidth, childView.getMeasuredHeight()); childLeft += childWidth; &#125; &#125; &#125; private void smoothScrollBy(int dx, int dy) &#123; mScroller.startScroll(getScrollX(), 0, dx, 0, 500); invalidate(); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; &#125; @Override protected void onDetachedFromWindow() &#123; mVelocityTracker.recycle(); super.onDetachedFromWindow(); &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://sparkyuan.github.io/tags/Android/"},{"name":"View","slug":"View","permalink":"http://sparkyuan.github.io/tags/View/"},{"name":"弹性滑动","slug":"弹性滑动","permalink":"http://sparkyuan.github.io/tags/弹性滑动/"}]},{"title":"AIDL","date":"2016-03-11T12:46:25.000Z","path":"2016/03/11/AIDL/","text":"介绍Android Interface Definition Language (AIDL)， Android接口定义语言。系统中的进程之间不能共享内存，因此，需要提供一些机制在不同进程之间进行数据通信Interprocess communication (IPC)。AIDL就是解决这个问题的。阅读本文需要了解Service的相关知识，关于Service的讲解请参考http://blog.csdn.net/l664675249/article/details/48899323 创建.aidl文件aidl是用Java语法编写的，后缀为.aidl的文件。 每一个aidl文件必须定义一个接口，在这个接口里声明方法 在aidl里不能有static属性（field） aidl支持基本的数据类型，当你需要使用额外的数据类型时需要把它们import进来，即使它们跟这个文件在同一个包中。 示例12345678910111213141516// IRemoteService.aidlpackage com.example.android;// Declare any non-default types here with import statements/** Example service interface */interface IRemoteService &#123; /** Request the process ID of this service, to do evil things with it. */ int getPid(); /** Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 把aidl文件存在src/目录下，当你build项目的时候，SDK工具会在gen/目录下生成一个与.aidl文件名字相同的.java文件。 实现接口生成的IRemoteService.java如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public interface IRemoteService extends android.os.IInterface&#123;/** Local-side IPC implementation stub class. */public static abstract class Stub extends android.os.Binder implements com.spark.meizi.IRemoteService&#123;private static final java.lang.String DESCRIPTOR = \"com.spark.meizi.IRemoteService\";/** Construct the stub at attach it to the interface. */public Stub()&#123;this.attachInterface(this, DESCRIPTOR);&#125;/** * Cast an IBinder object into an com.spark.meizi.IRemoteService interface, * generating a proxy if needed. */public static com.spark.meizi.IRemoteService asInterface(android.os.IBinder obj)&#123;if ((obj==null)) &#123;return null;&#125;android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);if (((iin!=null)&amp;&amp;(iin instanceof com.spark.meizi.IRemoteService))) &#123;return ((com.spark.meizi.IRemoteService)iin);&#125;return new com.spark.meizi.IRemoteService.Stub.Proxy(obj);&#125;@Override public android.os.IBinder asBinder()&#123;return this;&#125;@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;switch (code)&#123;case INTERFACE_TRANSACTION:&#123;reply.writeString(DESCRIPTOR);return true;&#125;case TRANSACTION_basicTypes:&#123;data.enforceInterface(DESCRIPTOR);int _arg0;_arg0 = data.readInt();long _arg1;_arg1 = data.readLong();boolean _arg2;_arg2 = (0!=data.readInt());float _arg3;_arg3 = data.readFloat();double _arg4;_arg4 = data.readDouble();java.lang.String _arg5;_arg5 = data.readString();this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);reply.writeNoException();return true;&#125;&#125;return super.onTransact(code, data, reply, flags);&#125;private static class Proxy implements com.spark.meizi.IRemoteService&#123;private android.os.IBinder mRemote;Proxy(android.os.IBinder remote)&#123;mRemote = remote;&#125;@Override public android.os.IBinder asBinder()&#123;return mRemote;&#125;public java.lang.String getInterfaceDescriptor()&#123;return DESCRIPTOR;&#125;/** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */@Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException&#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();try &#123;_data.writeInterfaceToken(DESCRIPTOR);_data.writeInt(anInt);_data.writeLong(aLong);_data.writeInt(((aBoolean)?(1):(0)));_data.writeFloat(aFloat);_data.writeDouble(aDouble);_data.writeString(aString);mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);_reply.readException();&#125;finally &#123;_reply.recycle();_data.recycle();&#125;&#125;&#125;static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);&#125;/** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException;&#125; 在这个文件中有一个内部类Stub，这是父接口的一个抽象实现，并声明了aidl中的所有方法。为了实现由aidl生成的接口，我们需要继承Stub并实现从aidl继承过来的方法。下面是一个使用匿名类的例子 123456789private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125;&#125;; 这样mBinder就是一个Stub的实例了，下一步就是如何在client端使用，与service端产生交互了。注： 不能保证请求是在主线程被执行的，所以从构建到使用要考虑Service线程的安全性 默认情况下，请求是同步的，所以尽量不要在主线程中发出请求 所有的异常都不会返回给请求者（Caller） 在Client中使用接口当你已经实现你的Service之后，你需把它暴露在Client中使Client可以绑定它。继承Service并实现onBind()方法，来返回一个实现了Stub的实例。下面就是一个把IRemoteService暴露给Client的例子： 12345678910111213141516171819202122public class RemoteService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; // Return the interface return mBinder; &#125; private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125; &#125;;&#125; 现在client（比如是一个Activity）可以调用bindService()来连接这个Service，通过onServiceConnected()来接收Service中 onBind() 返回的mBinder，最后使用YourServiceInterface.Stub.asInterface(service)来把返回的mBinder转换成YourServiceInterface类型。例子如下： 123456789101112131415IRemoteService mIRemoteService;private ServiceConnection mConnection = new ServiceConnection() &#123; // Called when the connection with the service is established public void onServiceConnected(ComponentName className, IBinder service) &#123; // Following the example above for an AIDL interface, // this gets an instance of the IRemoteInterface, which we can use to call on the service mIRemoteService = IRemoteService.Stub.asInterface(service); &#125; // Called when the connection with the service disconnects unexpectedly public void onServiceDisconnected(ComponentName className) &#123; Log.e(TAG, \"Service has unexpectedly disconnected\"); mIRemoteService = null; &#125;&#125;; 注：如果Service和Client在两个不同的Application中，Client的Application的src/目录下必须也有对应的.aidl文件。 一个Client的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202public static class Binding extends Activity &#123; /** The primary interface we will be calling on the service. */ IRemoteService mService = null; /** Another interface we use on the service. */ ISecondary mSecondaryService = null; Button mKillButton; TextView mCallbackText; private boolean mIsBound; /** * Standard initialization of this activity. Set up the UI, then wait * for the user to poke it before doing anything. */ @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.remote_service_binding); // Watch for button clicks. Button button = (Button)findViewById(R.id.bind); button.setOnClickListener(mBindListener); button = (Button)findViewById(R.id.unbind); button.setOnClickListener(mUnbindListener); mKillButton = (Button)findViewById(R.id.kill); mKillButton.setOnClickListener(mKillListener); mKillButton.setEnabled(false); mCallbackText = (TextView)findViewById(R.id.callback); mCallbackText.setText(\"Not attached.\"); &#125; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the service object we can use to // interact with the service. We are communicating with our // service through an IDL interface, so get a client-side // representation of that from the raw service object. mService = IRemoteService.Stub.asInterface(service); mKillButton.setEnabled(true); mCallbackText.setText(\"Attached.\"); // We want to monitor the service for as long as we are // connected to it. try &#123; mService.registerCallback(mCallback); &#125; catch (RemoteException e) &#123; // In this case the service has crashed before we could even // do anything with it; we can count on soon being // disconnected (and then reconnected if it can be restarted) // so there is no need to do anything here. &#125; // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_connected, Toast.LENGTH_SHORT).show(); &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mKillButton.setEnabled(false); mCallbackText.setText(\"Disconnected.\"); // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_disconnected, Toast.LENGTH_SHORT).show(); &#125; &#125;; /** * Class for interacting with the secondary interface of the service. */ private ServiceConnection mSecondaryConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // Connecting to a secondary interface is the same as any // other interface. mSecondaryService = ISecondary.Stub.asInterface(service); mKillButton.setEnabled(true); &#125; public void onServiceDisconnected(ComponentName className) &#123; mSecondaryService = null; mKillButton.setEnabled(false); &#125; &#125;; private OnClickListener mBindListener = new OnClickListener() &#123; public void onClick(View v) &#123; // Establish a couple connections with the service, binding // by interface names. This allows other applications to be // installed that replace the remote service by implementing // the same interface. Intent intent = new Intent(Binding.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); intent.setAction(ISecondary.class.getName()); bindService(intent, mSecondaryConnection, Context.BIND_AUTO_CREATE); mIsBound = true; mCallbackText.setText(\"Binding.\"); &#125; &#125;; private OnClickListener mUnbindListener = new OnClickListener() &#123; public void onClick(View v) &#123; if (mIsBound) &#123; // If we have received the service, and hence registered with // it, then now is the time to unregister. if (mService != null) &#123; try &#123; mService.unregisterCallback(mCallback); &#125; catch (RemoteException e) &#123; // There is nothing special we need to do if the service // has crashed. &#125; &#125; // Detach our existing connection. unbindService(mConnection); unbindService(mSecondaryConnection); mKillButton.setEnabled(false); mIsBound = false; mCallbackText.setText(\"Unbinding.\"); &#125; &#125; &#125;; private OnClickListener mKillListener = new OnClickListener() &#123; public void onClick(View v) &#123; // To kill the process hosting our service, we need to know its // PID. Conveniently our service has a call that will return // to us that information. if (mSecondaryService != null) &#123; try &#123; int pid = mSecondaryService.getPid(); // Note that, though this API allows us to request to // kill any process based on its PID, the kernel will // still impose standard restrictions on which PIDs you // are actually able to kill. Typically this means only // the process running your application and any additional // processes created by that app as shown here; packages // sharing a common UID will also be able to kill each // other's processes. Process.killProcess(pid); mCallbackText.setText(\"Killed service process.\"); &#125; catch (RemoteException ex) &#123; // Recover gracefully from the process hosting the // server dying. // Just for purposes of the sample, put up a notification. Toast.makeText(Binding.this, R.string.remote_call_failed, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125;; // ---------------------------------------------------------------------- // Code showing how to deal with callbacks. // ---------------------------------------------------------------------- /** * This implementation is used to receive callbacks from the remote * service. */ private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() &#123; /** * This is called by the remote service regularly to tell us about * new values. Note that IPC calls are dispatched through a thread * pool running in each process, so the code executing here will * NOT be running in our main thread like most other things -- so, * to update the UI, we need to use a Handler to hop over there. */ public void valueChanged(int value) &#123; mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0)); &#125; &#125;; private static final int BUMP_MSG = 1; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BUMP_MSG: mCallbackText.setText(\"Received from service: \" + msg.arg1); break; default: super.handleMessage(msg); &#125; &#125; &#125;;&#125;","tags":[{"name":"AIDL","slug":"AIDL","permalink":"http://sparkyuan.github.io/tags/AIDL/"},{"name":"IPC","slug":"IPC","permalink":"http://sparkyuan.github.io/tags/IPC/"}]},{"title":"View事件分发机制","date":"2016-03-11T12:46:25.000Z","path":"2016/03/11/View事件分发机制/","text":"介绍点击事件的事件分发就是对MotionEvent事件的分发过程，当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发的过程。 涉及到的三个方法 dispatchTouchEvent：用来进行事件的分发，如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和View的dispatchTouchEvent方法的影响，表示是否当消耗当前事件 onInterceptTouchEvent：用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件； onTouchEvent：在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。 三个方法之间的关系123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if(onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume; &#125; 上面的伪代码很好的描述了三者之间的关系。如果当前View拦截事件，就交给自己的onTouchEvent去处理，否则就传给子View，直到事件被最终处理。 事件分发顺序当一个点击事件产生后，它的传递过程如下：Activity -&gt; Window -&gt; View。如果View的onTouchEvent返回false，那么它的父容器onTouchEvent将会被调用，以此类推，最终将由Activity的onTouchEvent处理。 Activity对事件的分发过程Activity -&gt; Window -&gt; DecorView。 Windows是一个抽象类，可以控制顶级View的外观和行为策略，PhoneWindow是这个类的唯一个实现。DecorView就是当前界面的底层容器，即setContentView所设置的View是它的一个子View。 顶级View对点击事件的分发过程ViewGroup -&gt; dispatchTouchEvent -&gt; onInterceptTouchEvent -&gt; onTouch or onTouchEvent 顶级View一般都是一个ViewGroup。拦截事件之后，如果ViewGroup设置了mOnTouchListener，则Listener里的onTouch方法会屏蔽掉onTouchEvent。如果onTouchEvent设置了mOnClickListener，则Listener里的onClick会被调用。如果ViewGroup没有拦截则传给子View直到整个事件分发完成。 ##View对点击事件的处理过程如果View设置了mOnTouchListener，则Listener里的onTouch方法会屏蔽掉onTouchEvent。如果onTouchEvent设置了mOnClickListener，则Listener里的onClick会被调用。View没有onInterceptTouchEvent方法，一旦有点击事件传递给他，他就会处理。 注：上面只是描述了事件分发过程的原理，关于源码的分析请参考书本的相应章节。 欢迎转载，转载请注明出处http://sparkyuan.github.io/","tags":[{"name":"Android","slug":"Android","permalink":"http://sparkyuan.github.io/tags/Android/"},{"name":"View","slug":"View","permalink":"http://sparkyuan.github.io/tags/View/"},{"name":"事件分发机制","slug":"事件分发机制","permalink":"http://sparkyuan.github.io/tags/事件分发机制/"}]},{"title":"ViewRoot、DecorView、MeasureSpec和View的工作原理","date":"2016-03-11T12:46:25.000Z","path":"2016/03/11/View的工作原理/","text":"View的绘制流程是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽和高，layout用来确定View在父容器中的放置位置，而draw则负责将View绘制在屏幕上。 ViewRoot和DecorViewViewRoot ViewRoot对应ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均通过ViewRoot来完成。 ActivityThread中，Activity创建完成后，会将DecorView添加到Window中，同时创建ViewRootImpl对象，并建立两者的关联。 DecorView DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分（具体情况和Android版本及主体有关），上面的是标题栏，下面的是内容栏。在Activity中通过setContentView所设置的布局文件其实就是被加到内容栏之中的，而内容栏的id是content，在代码中可以通过ViewGroup content = （ViewGroup)findViewById(R.android.id.content)来得到content对应的layout。 DecorView其实是一个FrameLayout，View层的事件都先经过DecorView，然后才传递给我们的View。 MeasureSpec在测量过程中，系统会将View的LayoutParams根据父容器所施加的规则转换成对应的MeasureSpec，然后再根据这个MeasureSpec来测量出View的宽和高。测量出来的宽和高不一定等于View最终的宽和高。 MeasureSpec将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，高2位代表SpecMode，低30位代表SpecSize，SpecMode是指测量模式，而SpecSize是指在某种测量模式下的规格大小。SpecMode有三类： UNSPECIFIED：父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量状态 EXACTLY：父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式 AT_MOST：父容器指定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。 普通MeasureSpec的创建规则对于普通View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定。 子View为精确宽高，无论父容器的MeasureSpec，子View的MeasureSpec都为精确值且遵循LayoutParams中的值。 子View为match_parent时，如果父容器是精确模式，则子View也为精确模式且为父容器的剩余空间大小；如果父容器是最大模式，则子View也是最大模式且其大小不会超过父容器的剩余空间。 子View为wrap_content时，无论父View是精确还是最大模式，子View的模式总是最大模式，且不会超过父容器的剩余空间。 View的工作流程measureViewGroup的measure方法会遍历每个子元素，并调用子元素内部的measure方法，measure源码如下：1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 注： getDefaultSize()返回MeasureSpec中的specSize，也就是View测量后的大小。 getSuggestedMinimumWidth()，View如果没有背景，那么返回android:minWidth这个属性指定的值，这个值可以为0；如果设置了背景，则返回背景的最小宽度和minWidth中的最大值。 getSuggestedMinimumHeight()，与getSuggestedMinimumWidth()类似。 直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content时就相当于使用match_parent。因为LayoutParams=wrap_content的情况下，MeasureSpec为AT_MOST，所以View的宽和高为父容器当前剩余的空间，这种效果与match_parent一致。具体处理方法要根据需求灵活决定。 如何得到View的宽和高在Activity的onCreate、onStart、onResume方法中均无法正确得到某个View的宽/高信息，这是因为View的measure过程和Activity的生命周期方法不是同步执行的，因此无法保证Activity执行了onCreate、onStart、onResume时某个View就已经测量完毕了，如果View还没有测量完毕，那么获得的宽/高就是0。 可以通过如下四个方法来解决这个问题： Activity或者View的onWindowFocusChanged方法（注意该方法会在Activity Pause和resume时被多次调用） view.post(new Runnable( {@Overidde public void run(){})})，在run方法中获取。 ViewTreeObserver中的onGlobalLayoutListener中。 手动调用View的measure方法。示例代码请参考原书P190页 layoutlayout的作用是用来确定子视图在父视图中的位置。源码如下： 1234567891011121314151617181920212223public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123; if (ViewDebug.TRACE_HIERARCHY) &#123; ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT); &#125; onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~LAYOUT_REQUIRED; if (mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;) mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~FORCE_LAYOUT; &#125; 通过setFrame()确定四个顶点的位置，进而确定View在父容器中的位置。 在View的默认实现中，View的测量宽/高和最终宽/高是相等的，只不过测量宽/高形成于View的measure过程，而最终宽/高形成于View的layout过程，即两者的赋值时机不同，测量宽/高的赋值时机稍微早一些。多数情况下可以认为View的测量宽/高就等于最终的宽/高，但对于在View的layout中改变了View的left、top、right、bottom四个属性时，得出的测量宽/高有可能和最终的宽/高不一致。 drawdraw的过程很简单主要有以下几步： 绘制背景(background.draw) 绘制自己(onDraw) 绘制children(dispatchDraw) 绘制装饰(onDrawScrollBars)。 源码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void draw(Canvas canvas) &#123; / * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background if need * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children (dispatchDraw) * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ //Step 1, draw the background, if needed if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // we're done... return; &#125; // Step 2, save the canvas' layers ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); &#125; 注： View有一个特殊的方法setWillNotDraw，如果一个View不需要绘制任何内容，设置这个标记位true后，系统会进行优化。默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。 这个标记位对实际开发的意义是：如果自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。当明确知道一个ViewGroup需要通过onDraw来绘制内容时，需要显示地关闭WILL_NOT_DRAW这个标记位。 欢迎转载，转载请注明出处http://sparkyuan.me/","tags":[{"name":"Android","slug":"Android","permalink":"http://sparkyuan.github.io/tags/Android/"},{"name":"View","slug":"View","permalink":"http://sparkyuan.github.io/tags/View/"}]},{"title":"IntentFilter匹配规则详解","date":"2016-02-06T06:51:51.000Z","path":"2016/02/06/IntentFilter匹配规则/","text":"启动Activity的方式分为两种，显示和隐式调用。显示调用很简单，直接指明要启动的Activity就可以了，这里主要介绍一下隐式调用。隐式调用需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息。只有一个Intent同时匹配action，category和data才算匹配成功。 示例12345678910&lt;intent-filter&gt; &lt;action android:name=&quot;com.sparkyuan.c&quot; /&gt; &lt;action android:name=&quot;com.sparkyuan.d&quot; /&gt; &lt;category android:name=&quot;com.sparkyuan.c&quot; /&gt; &lt;category android:name=&quot;com.sparkyuan.d&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;text/plain&quot; /&gt;&lt;/intent-filter&gt;` action匹配规则action是一个字符串，系统预定义了一些action，我们也可以自己定义action。添加方法 1intent.setAction(\"com.sparkyuan.a\"); 注： 一个intent-filter中可以有多个action intent中的action与intent-filter中有一个相同即可 action区分大小写； category匹配规则添加方法 1intent.addCategory(\"com.sparkyuan.d\"); 注： intent中可以不存在category，但如果存在就必须匹配intent-filter其中一个 系统在startActivity或者startActivityForResult的时候默认为Intent加上一个android.intent.category.DEAFAULT，所以必须在intent-filter中加上android.intent.category.DEFAULT这个category data匹配规则data语法1234567&lt;data android:scheme=&quot;http&quot; android:host=&quot;www.baidu.com&quot; android:port=&quot;80&quot; android:path=&quot;string&quot; android:pathPattern=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:mimeType=&quot;text/plain&quot; /&gt; 组成data由两部分组成，mimeType和URI。URI格式如下：123&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]//示例content://com.example.project:200/folder/subfolder/etc ##匹配规则匹配规则与action类似，只要有一个data匹配就可以。 注：1&lt;data android:mimeType=&quot;text/plain&quot; /&gt; 虽然没有指定URI，但是URI有默认值，默认值为content和file，所以intent的URI部分必须为content或者file才可以。下面的方法可以匹配他 1intent.setDataAndType(Uri.parse(&quot;file://abc&quot;),&quot;text/plain&quot;); 最后intent-filter的规则对于Service和BroadcastReceiver是一样的，但是对于Service建议尽量使用显示方法来启动。在使用隐式Intent时可以先对是否有相应的Activity做出判断，以防出错。采用PackageManager的resolveActivity方法或者Intent的resolveActivity，如果匹配不到就返回null。 12contex.getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);intent.resolveActivity(getPackageManager()); MATCH_DEFAULT_ONLY的目的是去除那些category中不含DEFAULT的Activity。","tags":[{"name":"IntentFilter","slug":"IntentFilter","permalink":"http://sparkyuan.github.io/tags/IntentFilter/"},{"name":"匹配规则","slug":"匹配规则","permalink":"http://sparkyuan.github.io/tags/匹配规则/"}]},{"title":"Activity在异常情况下的生命周期","date":"2016-02-05T08:46:25.000Z","path":"2016/02/05/Activity在异常情况下的生命周期/","text":"关于Activity正常情况下的生命周期讲解的文章已经很多了，本文讲解一下Activity在异常情况下的生命周期。 情况1：资源相关的系统配置发生改变资源相关的系统配置发生改变，举个栗子。当前Activity处于竖屏状态的时候突然转成横屏，系统配置发生了改变，Activity就会销毁并且重建，其onPause, onStop, onDestory均会被调用。因为实在异常情况下终止的，所以系统会调用onSaveInstanceState来保存当前Activity状态。这个方法是在onStop之前，与onPause没有固定的时序关系。当Activity重建的时候系统会把onSaveInstanceState所保存的Bundle作为对象传递给onRestoreInstanceState和onCreate方法。 注： View的源码中每个View都有onSaveInstanceState和onRestoreInstanceState这两个方法。 接收位置可以是onRestoreInstanceState和onCreate方法，区别是：onRestoreInstanceState如果被调用，参数Bundle一定是有值的，在onCreate中需要判断参数是否为null。 onSaveInstanceState只有在Activity即将销毁并有机会重新显示时才会调用，正常销毁的Activity生命周期中不会调用，比如：旋转屏幕，按Home键，启动新Activity等。 情况2：资源内存不足导致低优先级Activity被杀死Activity优先级 前台Activity——正在和用户交互的Activity，优先级最高 可见但非前台Activity——Activity中弹出的对话框导致Activity可见但无法交互 后台Activity——已经被暂停的Activity，优先级最低 系统内存不足是，会按照以上顺序杀死Activity，并通过onSaveInstanceState和onRestoreInstanceState这两个方法来存储和恢复数据。 不让Activity重新创建的方法系统配置有很多内容，当某项改变时，我们不想让Activity重新创建可以在AndroidMainfest中给Activity指定configChanges属性。比如1android:configChanges=\"orientation\" configChanges属性非常多，具体可参考官方文档常用的有locale, orientation和keyboardHidden这三个。","tags":[{"name":"Activity","slug":"Activity","permalink":"http://sparkyuan.github.io/tags/Activity/"}]},{"title":"我的Android Studio配置","date":"2015-10-04T08:15:25.000Z","path":"2015/10/04/我的Android Studio的配置/","text":"Android Studio固然好用，但是刚从Eclipse转移到Android Studio上难免有很多不便，现在集中整理一下AS与Eclipse的区别，使得AS更好用。 Android Studio固然好用，但是刚从Eclipse转移到Android Studio上难免有很多不便，现在集中整理一下AS与Eclipse的区别，使得AS更好用。 快捷键Keymap到Eclipse。 代码自动补全功能快捷键换成熟悉的Alt + / 代码自动补全的相关设置。下图是根据个人喜好选择的，仅供参考。 鼠标放在函数上自动显示函数的Doc 自动import需要使用的包","tags":[]}]