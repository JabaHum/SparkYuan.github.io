title: JVM内存区域分析
date: 2016/4/22 15:38:51
categories:
- JVM
tags:
- 深入理解JVM虚拟机

---
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。
<!-- more -->

![运行时数据区](/images/jvm_memory.png)

# 程序计数器（PC）
程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码行号指示器。
- 当前线程所执行的字节码行号指示器
- 每个线程都有一个
- 线程私有，生命周期与线程相同，随JVM启动而生，JVM关闭而死
- 线程执行Java方法时，记录其正在执行的虚拟机字节码指令地址
- 线程执行Nativan方法时，计数器记录为空（Undefined）
- 唯一在Java虚拟机规范中没有规定任何OutOfMemoryError情况区域

# Java虚拟机栈
虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧 （Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
在Java虚拟机规范中，对于此区域规定了两种异常状况：
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
- 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。

# 本地方法栈
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用非常类似，区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。

# Java堆
Java堆是垃圾收集管理的主要战场。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的。
- 通过-Xmx和-Xms控制Heap大小
- 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

# 方法区
方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 方法区又称“永久代”(Permanent Generation)
- 使用XX:MaxPermSize调整最大值
- 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

# 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池表（Constant Pool Table）**，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。